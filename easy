EASY ONLY - All Database

*A good method to calculate MAX is to ORDER BY DESC and LIMIT 1

1) Average Selling Price - not too bad - redo

SELECT product_id, ROUND(SUM(price*units)/SUM(units),2) AS average_price    /*the SUM part is the difficult part*/
FROM prices JOIN UnitsSold USING (product_id)
WHERE purchase_date BETWEEN start_date AND end_date
GROUP BY product_id
ORDER BY product_id DESC;           /*SQL orders by ASC by default*/

*finished on paper 


2) Product Sales Analysis I - common on test 

SELECT product_name, year, price
FROM product JOIN sales USING (product_id);

*flashed on paper

3) Product Sales Analysis II - database - common on test

SELECT product_id, SUM(quantity) AS total_quantity
FROM Sales JOIN Product USING(product_id)
GROUP BY Sales.product_id;

OR

SELECT product_id, SUM(quantity) AS total_quantity
FROM Sales
GROUP BY product_id
ORDER By product_id DESC;

*flashed on paper


4) Game Play Analysis I - common on test

SELECT player_id, MIN(event_date) AS first_login
FROM Activity
GROUP BY player_id;

*flashed on paper

5) Big Countries - veru cp,,pm pm test

SELECT name, population, area
FROM World
WHERE area > 3000000 OR population > 25000000;

*flashed on paper


6) Immediate Food Delivery I - learn AVG with conditional - common on test

SELECT ROUND(100*(AVG(order_date = customer_pref_delivery_date),2) AS immediate_percentage  /*seems like AVG with (condition)*/
FROM delivery;

*did 2nd/3rd try on paper

7) Shortest Distance in a Line - hmm new thing to learn?

Calculate the distance between 2 points first, then display the minimum one.

To get the distances of each two points, we need to join this table with itself and use ABS() function.

SELECT MIN(ABS(P1.x-P2.x)) AS shortest
FROM point P1 JOIN point P2 ON P1.x != P2.x;   /*self-join and NOT equal*/

or

SELECT MIN(ABS(p1.x-p2.x)) AS shortest
FROM point p1 JOIN point p2 ON p1.x <> p2.x;   /*have to remember thsi part JOIN ON p1.x <> p2.x */

*did on 2nd/3rd try on paper

8) Reformat Department Table - new thing to learn - CASE(WHEN condition1 THEN result1 END) - very common on test

SELECT id,
SUM(CASE WHEN month = 'Jan' THEN revenue END) AS Jan_Revenue,
SUM(CASE WHEN month = 'Feb' THEN revenue END) AS Feb_Revenue,
SUM(CASE WHEN month = 'Mar' THEN revenue END) AS Mar_Revenue,
SUM(CASE WHEN month = 'Apr' THEN revenue END) AS Apr_Revenue,
SUM(CASE WHEN month = 'May' THEN revenue END) AS May_Revenue,
SUM(CASE WHEN month = 'Jun' THEN revenue END) AS Jun_Revenue,
SUM(CASE WHEN month = 'Jul' THEN revenue END) AS Jul_Revenue,
SUM(CASE WHEN month = 'Aug' THEN revenue END) AS Aug_Revenue,
SUM(CASE WHEN month = 'Sep' THEN revenue END) AS Sep_Revenue,
SUM(CASE WHEN month = 'Oct' THEN revenue END) AS Oct_Revenue,
SUM(CASE WHEN month = 'Nov' THEN revenue END) AS Nov_Revenue,
SUM(CASE WHEN month = 'Dec' THEN revenue END) AS Dec_Revenue
FROM Department
GROUP BY id;

*did on 2nd/3rd try on paper

9) Number of Comments per Post - do not fully understand the strange JOIN of S1.sub_id = S2.parent_id

SELECT S1.sub_id AS post_id, COUNT(DISTINCT S2.sub_id) AS number_of_comments
FROM Submissions S1 LEFT JOIN Submissions S2 ON S1.sub_id = S2.parent_id     /*do not fully understand this JOIN*/
WHERE S1.parent_id IS NULL      /*the question only wants answer from where S1.parent_id IS NULL*/
GROUP BY S1.sub_id;

*did on 3rd try on paper

10) Actors and Directors Who Cooperated At Least Three Times

SELECT actor_id, director_id
FROM ActorDirector
GROUP BY actor_id, director_id      /*no parentheses*/
HAVING COUNT(*) >= 3;

*GROUP BY actor_id - put all those with the same value for X in the one group
*GROUP BY actor_id, director_id - put all those with the same values for BOTH x and y in the one group

*did on 2nd try on paper

11) Article Views I  - common on test

SELECT DISTINCT author_id AS id
FROM Views
WHERE author_id = viewer_id
ORDER BY id ASC;                          /*I guess always do the ORDER BY ASC or DESC*/


SELECT DISTINCT author_id AS id
FROM Views
GROUP BY author_id, viewer_id
HAVING COUNT(*) > 3;                         /*this did not work*/ why?


*did it on 2nd try on paper

12) Swap Salary - single UPDATE statement, IF statement - very common on test

UPDATE salary
SET sex = IF(sex = 'm', 'f', 'm');

*did it on 2nd try on paper 

13) Sales Analysis I - need to redo - does not seem too hard

SELECT seller_id
FROM Sales
GROUP BY seller_id
HAVING SUM(price) = (
                     SELECT SUM(price) AS S
                     FROM Sales
                     GROUP BY seller_id
                     ORDER BY S DESC
                     LIMIT 1);
                     

SELECT seller_id
FROM Sales
GROUP BY seller_id
WHERE NOT EXISTS price < (
                          SELECT SUM(price)
                          FROM Sales
                          GROUP BY seller_id);      /*DID NOT WORK*/
                     
                                  

14) Find Customer Referee - common on test

SELECT name
FROM customer
WHERE referee_id IS NULL OR referee_id <> 2;

*redid 1 time on paper - did not flash

15) Customer Placing the Largest Number of Orders - somewhat easy - REDO

SELECT customer_number
FROM orders
GROUP BY customer_number
ORDER BY COUNT(*) DESC      /*customer number 3 COUNTS two times*/
LIMIT 1;

*took 2 tries on paper - it was easy though.... just have to remember concept

16) Queries Quality and Percentage - AVG(rating < 3) -> AVG condition   - REDO

SELECT query_name, ROUND(AVG(rating/position),2) AS quality, ROUND(AVG(rating <3)*100, 2) AS poor_query_percentage
FROM Queries
GROUP BY query_name
ORDER BY quality DESC;

*need to redo - will take 2-3 tries

17) Not Boring Movies - common on test

SELECT id, movie, description, rating
FROM cinema
WHERE description <> 'boring' AND (id%2) <> 0
ORDER BY rating DESC;

*flashed it

18) Triangle Judgement - IF or CASE statement - VERY COMMON on test

SELECT *
IF (x + y > z, x + z > y, y + z > x, 'Yes', 'No') AS triangle     /*triangle here is the column display header*/
FROM triangle;                                                    /*pull from the actual triangle table*/

OR

SELECT x, y, z
CASE
  WHEN x + y > z AND x + z > y AND y + z > x THEN 'Yes'
  ELSE 'No'
END AS Triangle
FROM Triangle;


19) Employee Bonus - REDO - LEFT JOIN to keep the NULLS from the LEFT table

SELECT name, bonus
FROM Employee LEFT JOIN Bonus USING(empId)
WHERE bonus < 1000 OR bonus IS NULL;

*flashed it on paper - just needed to remember LEFT JOIN

20) Project Employees I

SELECT project_id, ROUND(AVG(experience_year),2) AS average_years
FROM Project JOIN Employee USING(employee_id)
GROUP BY project_id;

*flashed it on paper

OR

SELECT project_id, CAST(AVG(experience_years) AS DECIMAL (10,2)) AS average_years
FROM Project JOIN Employee USING (employee_id)
GROUP BY project_id;



*****
CAST AS DECIMAL (10,2) - means 10 digits in total, with 2 after the decimal.

CREATE TABLE dbo.MyTable  
(  
  MyDecimalColumn decimal(5,2)  
,MyNumericColumn numeric(10,5)
  
);  
  
Answer:

 MyDecimalColumn                         MyNumericColumn  
--------------------------------------- ---------------------------------------  
123.00                                  12345.12000  


21) Consecutive Available Seats - just have to understand the JOIN ON criteria, consecutive seating, and boolean

SELECT DISTINCT C1.seat_id
FROM cinema C1 JOiN cinema C2 ON ABS(C1.seat_id - C2.seat_id) = 1   /*to test consecutive seating*/ /*ON as criteria */
AND C1.free = TRUE AND C2.free = TRUE       /*boolean */
ORDER BY C1.seat_id;

*did on 2nd try on paper

22) Reported Posts - VERY COMMON on test

SELECT extra AS report_reason, COUNT(DISTINCT post_id) AS report_count
FROM Actions
WHERE action_date = '2019-07-04' AND action = 'report'
GROUP BY extra
ORDER BY report_count ASC;

*did on 2nd try on paper

23) Sales Person - all salespeople who did not sell to company 'RED', i.e. com_id = 1 - a bit harder. Have to 
really understand the logic and all the tables.

SELECT salesperson.name
FROM salesperson 
WHERE salesperson.sales_id NOT IN(
                                  SELECT salesperson.sales_id
                                  FROM salesperson JOIN orders USING (sales_id) JOIN company USING (com_id)
                                  WHERE company.name = 'RED');

*got it after 2nd, 3rd try of understanding relationship on paper

24) Duplicate Emails - quite common on test

SELECT Email
FROM Person
GROUP BY Email
HAVING COUNT(*) > 1;

*flashed on paper 

25) Combine Two Tables - VERY COMMON on tests

SELECT FirstName, LastName, City, State
FROM Person LEFT JOIN Address USING (PersonId);   /*LEFT JOIN - to keep the NULLS*/

*messed up the using JOIN ON instead of USING - redo again


26) Game Play Analysis II - need to redo - WHERE("1", "2") IN 

SELECT player_id, device_id
FROM Activity 
WHERE (player_id, event_date) IN(
                                 SELECT player_id, MIN(event_date)
                                 FROM Activity
                                 GROUP BY player_id);


27) User Activity for the Past 30 Days I - not too bad - study and REDO

SELECT activity_date AS day, COUNT(DISTINCT(user_id) AS active_users
FROM Activity
WHERE activity_date BETWEEN '2019-06-28' AND  '2019-07-27'          /*BETWEEN dates*/
GROUP BY day;

*got it after 1st try - activity_date BETWEEN the dates, not activity_date > 2019-07-20

28) Sales Analysis III - quite common on test - DO NOT UNDERSTAND - NEED TO STUDY THIS - look at discussion for why the answer is the way 
it is.

SELECT product_id, product_name
FROM product
WHERE product_id IN(SELECT product_id
                    FROM Sales
                    GROUP BY product_id
                    HAVING MIN(sale_date) >= '2019-01-01' AND MAX(sale_date) <= '2019-03-31');

OR

SELECT product_id, product_name
FROM Product  JOIN Sales USING (product_id)
GROUP BY Product.product_id
HAVING COUNT(*) = SUM(
                      CASE 
                        WHEN sale_date BETWEEN '2019-01-01' AND '2019-03-31' THEN 1 
                        ELSE 0 
                       END);


The SQL CASE Statement
The CASE statement goes through conditions and returns a value when the first condition is met (like an IF-THEN-ELSE statement). So, once a condition is true, it will stop reading and return the result. If no conditions are true, it returns the value in the ELSE clause.

If there is no ELSE part and no conditions are true, it returns NULL.

CASE Syntax
CASE
    WHEN condition1 THEN result1
    WHEN condition2 THEN result2
    WHEN conditionN THEN resultN
    ELSE result
END;


OR
 


29) Project Employees II - need to REDO - a bit harder

SELECT project_id 
FROM Project
GROUP BY project_id
HAVING COUNT(employee_id) = (
                             SELECT COUNT(employee_id) 
                             FROM Project 
                             GROUP BY project_id 
                             ORDER BY count(employee_id) DESC 
                             LIMIT 1);


30) Employees Earning More Than Their Managers - a bit tricky, need to think about it after studying solution - REDO

SELECT E1.Name AS Employee 
FROM Employee E1, Employee E2 
WHERE E1.Salary > E2.Salary and E1.ManagerId = E2.Id;


31) Sales Analysis II - not really sure 

Select list who bought S8, select list who bought iphone. Select only list who bought S8 and not list who bought iPhone

SELECT DISTINCT s.buyer_id
FROM Sales s LEFT JOIN Product p           /*why do we need a LEFT JOIN?*/
ON s.product_id = p.product_id
WHERE p.product_name = "S8"
AND s.buyer_id NOT IN 
(
    SELECT DISTINCT s.buyer_id
    FROM sales s LEFT JOIN product p
    ON s.product_id = p.product_id
    WHERE p.product_name = "iPhone" 
)


32) Customers Who Never Order

SELECT Name AS Customers
FROM Customers 
WHERE Customers.Id NOT IN (
                            SELECT CustomerId
                            FROM Orders);


32) Friend Requests I: Overall Acceptance Rate - medium hard



                      
33) Biggest Single Number - medium hard - have to redo again... need to SUBQUERY THE FROM.... why?

SELECT MAX(num) AS num
FROM (SELECT num
      FROM my_numbers
      GROUP BY num
      HAVING COUNT(*) <= 1) AS a;


34) Classes More Than 5 Students - need to COUNT(DISTINCT student) to avoid duplication

SELECT class
FROM courses
GROUP BY class
HAVING COUNT(DISTINCT student) >= 5;

35) Rising Temperature - involves dates - DATEDIFF() function to compare two date type values 


36) Delete Duplicate Emails - sort of easy


37) User Activity for the Past 30 Days II


38) Second Highest Salary

SELECT MAX(Salary) AS SecondHighestSalary
FROM Employee E1
WHERE E1.Salary < (
                   SELECT MAX(Salary)
                   FROM Employee E2);



DONE! THAT IS ALL THE EASY LEETCODE QUESTIONS - CONGRATULATIONS!






