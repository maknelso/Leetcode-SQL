EASY ONLY - All Database


1) Average Selling Price - not too bad - redo

SELECT product_id, ROUND(SUM(price*units)/SUM(units),2) AS average_price    /*the SUM part is the difficult part*/
FROM prices JOIN UnitsSold USING (product_id)
WHERE purchase_date BETWEEN start_date AND end_date
GROUP BY product_id
ORDER BY product_id DESC;           /*SQL orders by ASC by default*/

*finished on paper 


2) Product Sales Analysis I

SELECT product_name, year, price
FROM product JOIN sales USING (product_id);

*flashed on paper

3) Product Sales Analysis II - database

SELECT product_id, SUM(quantity) AS total_quantity
FROM Sales JOIN Product USING(product_id)
GROUP BY Sales.product_id;

OR

SELECT product_id, SUM(quantity) AS total_quantity
FROM Sales
GROUP BY product_id
ORDER By product_id DESC;

*flashed on paper


4) Game Play Analysis I

SELECT player_id, MIN(event_date) AS first_login
FROM Activity
GROUP BY player_id;

*flashed on paper

5) Big Countries

SELECT name, population, area
FROM World
WHERE area > 3000000 OR population > 25000000;

*flashed on paper


6) Immediate Food Delivery I - learn AVG with conditional

SELECT ROUND(100*(AVG(order_date = customer_pref_delivery_date),2) AS immediate_percentage  /*seems like AVG with (condition)*/
FROM delivery;

*did 2nd/3rd try on paper

7) Shortest Distance in a Line - hmm new thing to learn?

Calculate the distance between 2 points first, then display the minimum one.

To get the distances of each two points, we need to join this table with itself and use ABS() function.

SELECT MIN(ABS(P1.x-P2.x)) AS shortest
FROM point P1 JOIN point P2 ON P1.x != P2.x;   /*self-join and NOT equal*/

or

SELECT MIN(ABS(p1.x-p2.x)) AS shortest
FROM point p1 JOIN point p2 ON p1.x <> p2.x;   /*have to remember thsi part JOIN ON p1.x <> p2.x */

*did on 2nd/3rd try on paper

8) Reformat Department Table - new thing to learn - CASE(WHEN condition1 THEN result1 END)

SELECT id,
SUM(CASE WHEN month = 'Jan' THEN revenue END) AS Jan_Revenue,
SUM(CASE WHEN month = 'Feb' THEN revenue END) AS Feb_Revenue,
SUM(CASE WHEN month = 'Mar' THEN revenue END) AS Mar_Revenue,
SUM(CASE WHEN month = 'Apr' THEN revenue END) AS Apr_Revenue,
SUM(CASE WHEN month = 'May' THEN revenue END) AS May_Revenue,
SUM(CASE WHEN month = 'Jun' THEN revenue END) AS Jun_Revenue,
SUM(CASE WHEN month = 'Jul' THEN revenue END) AS Jul_Revenue,
SUM(CASE WHEN month = 'Aug' THEN revenue END) AS Aug_Revenue,
SUM(CASE WHEN month = 'Sep' THEN revenue END) AS Sep_Revenue,
SUM(CASE WHEN month = 'Oct' THEN revenue END) AS Oct_Revenue,
SUM(CASE WHEN month = 'Nov' THEN revenue END) AS Nov_Revenue,
SUM(CASE WHEN month = 'Dec' THEN revenue END) AS Dec_Revenue
FROM Department
GROUP BY id;

*did on 2nd/3rd try on paper

9) Number of Comments per Post - do not fully understand the strange JOIN of S1.sub_id = S2.parent_id

SELECT S1.sub_id AS post_id, COUNT(DISTINCT S2.sub_id) AS number_of_comments
FROM Submissions S1 LEFT JOIN Submissions S2 ON S1.sub_id = S2.parent_id     /*do not fully understand this JOIN*/
WHERE S1.parent_id IS NULL      /*the question only wants answer from where S1.parent_id IS NULL*/
GROUP BY S1.sub_id;

*did on 3rd try on paper

10) Actors and Directors Who Cooperated At Least Three Times

SELECT actor_id, director_id
FROM ActorDirector
GROUP BY actor_id, director_id      /*no parentheses*/
HAVING COUNT(*) >= 3;

*GROUP BY actor_id - put all those with the same value for X in the one group
*GROUP BY actor_id, director_id - put all those with the same values for BOTH x and y in the one group

*did on 2nd try on paper

11) Article Views I 

SELECT DISTINCT author_id AS id
FROM Views
WHERE author_id = viewer_id
ORDER BY id ASC;                          /*I guess always do the ORDER BY ASC or DESC*/


SELECT DISTINCT author_id AS id
FROM Views
GROUP BY author_id, viewer_id
HAVING COUNT(*) > 3;                         /*this did not work*/ why?


*did it on 2nd try on paper

12) Swap Salary - single UPDATE statement, IF statement

UPDATE salary
SET sex = IF(sex = 'm', 'f', 'm');

*did it on 2nd try on paper 

13) Sales Analysis I - need to redo - does not seem too hard

SELECT seller_id
FROM Sales
GROUP BY seller_id
HAVING SUM(price) = (
                     SELECT SUM(price) AS S
                     FROM Sales
                     GROUP BY seller_id
                     ORDER BY S DESC
                     LIMIT 1);
                     

SELECT seller_id
FROM Sales
GROUP BY seller_id
WHERE NOT EXISTS price < (
                          SELECT SUM(price)
                          FROM Sales
                          GROUP BY seller_id);      /*DID NOT WORK*/
                     
                                  

14) Find Customer Referee

SELECT name
FROM customer
WHERE referee_id IS NULL OR referee_id <> 2;

*redid 1 time on paper - did not flash

15) Customer Placing the Largest Number of Orders - somewhat easy - REDO

SELECT customer_number
FROM orders
GROUP BY customer_number
ORDER BY COUNT(*) DESC
LIMIT 1;


16) Queries Quality and Percentage - poor_query_percentage do not fully get - REDO

SELECT query_name, ROUND(AVG(rating/position),2) AS quality, ROUND(AVG(rating <3)*100, 2) AS poor_query_percentage
FROM Queries
GROUP BY query_name
ORDER BY quality DESC;


17) Not Boring Movies

SELECT id, movie, description, rating
FROM cinema
WHERE description <> 'boring' AND (id%2) <> 0
ORDER BY rating DESC;


18) Triangle Judgement - recursion - **need to learn


19) Employee Bonus - REDO - LEFT JOIN to keep the NULLS, OR bonus IS NULL to show the nulls

SELECT name, bonus
FROM Employee LEFT JOIN Bonus USING(empId)
WHERE bonus < 1000 OR bonus IS NULL;


20) Project Employees I

SELECT project_id, CAST(AVG(experience_years) AS DECIMAL (10,2)) AS average_years
FROM Project JOIN Employee USING (employee_id)
GROUP BY project_id;

*****
CAST AS DECIMAL (10,2) - means 10 digits in total, with 2 after the decimal.

CREATE TABLE dbo.MyTable  
(  
  MyDecimalColumn decimal(5,2)  
,MyNumericColumn numeric(10,5)
  
);  
  
Answer:

 MyDecimalColumn                         MyNumericColumn  
--------------------------------------- ---------------------------------------  
123.00                                  12345.12000  


21) Consecutive Available Seats - a bit harder


22) Reported Posts - redo - DISTINCT post_id - why do you need?

SELECT extra AS report_reason, COUNT(DISTINCT post_id) AS report_count
FROM Actions
WHERE action_date = '2019-07-04' AND action = 'report'
GROUP BY extra;


23) Sales Person - does not seem too hard.... REDO

SELECT salesperson.name
FROM salesperson 
WHERE salesperson.sales_id NOT IN(
                                  SELECT salesperson.sales_id
                                  FROM salesperson JOIN orders USING (sales_id) JOIN company USING (com_id)
                                  WHERE company.name = 'RED');


24) Duplicate Emails

SELECT Email
FROM Person
GROUP BY Email
HAVING COUNT(*) > 1;


25) Combine Two Tables

SELECT FirstName, LastName, City, State
FROM Person LEFT JOIN Address USING (PersonId);   /*LEFT JOIN - to keep the NULLS*/


26) Game Play Analysis II - need to redo. Study this

SELECT player_id, device_id
FROM Activity 
WHERE (player_id, event_date) IN(
                                 SELECT DISTINCT player_id, MIN(event_date)
                                 FROM Activity
                                 GROUP BY player_id);


27) User Activity for the Past 30 Days I - not too bad - study and REDO

SELECT activity_date AS day, COUNT(DISTINCT(user_id)) AS active_users
FROM Activity
WHERE activity_date BETWEEN '2019-06-28' AND  '2019-07-27'
GROUP BY day;


28) Sales Analysis III - medium difficulty? - involves dates - study this and REDO - CASE

SELECT product_id, product_name
FROM Product  JOIN Sales USING (product_id)
GROUP BY Product.product_id
HAVING COUNT(*) = SUM(
                      CASE 
                        WHEN sale_date BETWEEN '2019-01-01' AND '2019-03-31' THEN 1 
                        ELSE 0 
                       END);


The SQL CASE Statement
The CASE statement goes through conditions and returns a value when the first condition is met (like an IF-THEN-ELSE statement). So, once a condition is true, it will stop reading and return the result. If no conditions are true, it returns the value in the ELSE clause.

If there is no ELSE part and no conditions are true, it returns NULL.

CASE Syntax
CASE
    WHEN condition1 THEN result1
    WHEN condition2 THEN result2
    WHEN conditionN THEN resultN
    ELSE result
END;


29) Project Employees II - need to REDO

SELECT project_id 
FROM Project
GROUP BY project_id
HAVING COUNT(employee_id) = (
                             SELECT COUNT(employee_id) 
                             FROM Project 
                             GROUP BY project_id 
                             ORDER BY count(employee_id) DESC 
                             LIMIT 1);


30) Employees Earning More Than Their Managers - a bit tricky, need to think about it after studying solution - REDO

SELECT E1.Name AS Employee 
FROM Employee E1, Employee E2 
WHERE E1.Salary > E2.Salary and E1.ManagerId = E2.Id;


31) Sales Analysis II - not really sure 

Select list who bought S8, select list who bought iphone. Select only list who bought S8 and not list who bought iPhone

SELECT DISTINCT s.buyer_id
FROM Sales s LEFT JOIN Product p           /*why do we need a LEFT JOIN?*/
ON s.product_id = p.product_id
WHERE p.product_name = "S8"
AND s.buyer_id NOT IN 
(
    SELECT DISTINCT s.buyer_id
    FROM sales s LEFT JOIN product p
    ON s.product_id = p.product_id
    WHERE p.product_name = "iPhone" 
)


32) Customers Who Never Order

SELECT Name AS Customers
FROM Customers 
WHERE Customers.Id NOT IN (
                            SELECT CustomerId
                            FROM Orders);


32) Friend Requests I: Overall Acceptance Rate - medium hard



                      
33) Biggest Single Number - medium hard - have to redo again... need to SUBQUERY THE FROM.... why?

SELECT MAX(num) AS num
FROM (SELECT num
      FROM my_numbers
      GROUP BY num
      HAVING COUNT(*) <= 1) AS a;


34) Classes More Than 5 Students - need to COUNT(DISTINCT student) to avoid duplication

SELECT class
FROM courses
GROUP BY class
HAVING COUNT(DISTINCT student) >= 5;

35) Rising Temperature - involves dates - DATEDIFF() function to compare two date type values 


36) Delete Duplicate Emails - sort of easy


37) User Activity for the Past 30 Days II


38) Second Highest Salary

SELECT MAX(Salary) AS SecondHighestSalary
FROM Employee E1
WHERE E1.Salary < (
                   SELECT MAX(Salary)
                   FROM Employee E2);



DONE! THAT IS ALL THE EASY LEETCODE QUESTIONS - CONGRATULATIONS!






