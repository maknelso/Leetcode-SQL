Difficulty: Medium
48 questions

Next set of 5 medium questions to do (by number sequence): 585, 602, 608, 612, 614

midway point: 24th question: 1132 - Reported Posts II

did 19/48 or 39.5%

REDO: All
Memorize: 177 (CREATE FUNCTION) -> CREATE, BEGIN, DECLARE, SET1, SET2, SET3,... RETURN

Notes:
-- writing pseudocode helps
-- 184. RANK() OVER(PARTITION BY 1ST ORDER BY 2ND) => 184. RANK() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS num
-- 184. have to RANK OVER(PARTITION BY DepartmentId), then DepartmentId next line -> otherwise error
-- 184. likely if you PARTITION BY DepartmentId, then DepartmentId must come AFTER
-- 534. SUM(games_played) OVER(PARTITION BY player_id ORDER BY event_date) AS games_played_so_far => SUM() OVER(PARTITION BY player_id ORDER BY event_date)
-> SUMS up game_played, segregated by player_id, segregated by the order of event_date
-- 570. To do COUNT(), you need GROUP BY. GROUP BY ManagerId, HAVING COUNT(ManagerId) >= 5 -> usually COUNT comes with GROUP BY
-- 574. Winning Candidate => If you want to COUNT, you need to GROUP BY usually
-- 1421. => USING(column1, column2) => FROM Queries LEFT JOIN NPV USING(id, year);

A*177. Nth Highest Salary -> CREATE FUNCTION    -> easy
                             BEGIN
                                DECLARE
                                SET
                                SET
                                RETURN
                             END                  -> looks like SELECT DISTINCT Salary returns NULL
# Write your MySQL query statement below
CREATE FUNCTION getNthHighestSalary(n INT) RETURNS INT
BEGIN
  DECLARE offsetvariable INT;
  SET offsetvariable = n - 1;
  RETURN (SELECT DISTINCT Salary 
          FROM Employee
          ORDER BY Salary DESC
          LIMIT 1 OFFSET offsetvariable);
END
#algorithm: n as input = 2
#SELECT DISTINCT Salary
#FROM Employee
#ORDER BY Salary DESC
#LIMIT 1 OFFSET (how many?)
#->if we want to get 2nd highest salary, offset 1
#->if we want 3rd highest salary, offset 2
#->set offset variable to be (n - 1)

A, W*178. Rank Scores -> easy
# Write your MySQL query statement below
# DENSE_RANK window function for no gaps
SELECT score,
DENSE_RANK() OVER(ORDER BY Score DESC) AS 'Rank'
FROM Scores
ORDER BY score DESC;

A*180. Consecutive Numbers -> easy
/* Write your T-SQL query statement below */
-- Consecutive means ID of Num are next to each other.
-- Use 3 aliases for this table Logs and then check whether 3 consecutive numbers are all the same
-- Check Ids are consecutive
-- Check Num from all 3 Logs l1, l2, l3 are the same
SELECT DISTINCT l1.Num AS ConsecutiveNums
FROM Logs l1, Logs l2, Logs l3
WHERE l1.Id = l2.Id - 1 AND l2.Id = l3.Id - 1
AND l1.Num = l2.Num AND l2.Num = l3.num;

A*184. Department Highest Salary -> Window function -> a bit harder
=> have to RANK OVER(PARTITION BY DepartmentId), then DepartmentId next line -> otherwise error
=> likely if you PARTITION BY DepartmentId, then DepartmentId must come AFTER

-- Window function
# Write your MySQL query statement below
SELECT Department.Name AS Department, Esub.Name As Employee, Esub.Salary
FROM (SELECT Name, Salary,
      RANK() OVER(PARTITION BY DepartmentId ORDER BY Salary DESC) AS r,
      DepartmentId
      FROM Employee) AS Esub
JOIN Department ON Esub.DepartmentId = Department.Id
WHERE Esub.r = 1;

-- Non-Window function
# Write your MySQL query statement below
-- IN subquery
SELECT Department.name AS 'Department', Employee.name AS 'Employee', Salary
FROM Employee JOIN Department ON Employee.DepartmentId = Department.Id
WHERE (Employee.DepartmentId, Salary) IN 
(SELECT DepartmentId, MAX(Salary)
 FROM Employee 
 GROUP BY DepartmentId);

534. Game Play Analysis III - did not flash
#Window function answer
# Write your MySQL query statement below
SELECT player_id, event_date, SUM(games_played) OVER(PARTITION BY player_id ORDER BY event_date) AS games_played_so_far
FROM Activity
ORDER BY player_id, event_date ASC;

#Non-window function answer -> don't fully get...
# Write your MySQL query statement below
SELECT a1.player_id, a1.event_date, SUM(a2.games_played) AS games_played_so_far
FROM activity a1, activity a2
WHERE a1.player_id = a2.player_id
AND a1.event_date >= a2.event_date
GROUP BY a1.player_id, a1.event_date
ORDER BY a1.player_id, a1.event_date;

550. Game Play Analysis IV -> half skipped
# Write your MySQL query statement below
# COUNT number of players that logged in for at least 2 conseuctive days 
SELECT ROUND(COUNT(DISTINCT player_id) / (SELECT COUNT(DISTINCT player_id) FROM Activity),2) as fraction 
FROM Activity
WHERE (player_id, DATE_SUB(event_date, INTERVAL 1 DAY)) 
IN (SELECT player_id, MIN(event_date) AS first_login 
    FROM Activity 
    GROUP BY player_id);

Below was my attempt, gives you correct 0.33, but not the correct thinking
# Write your MySQL query statement below
# COUNT number of players that logged in for at least 2 conseuctive days 
SELECT ROUND(a1.player_id / COUNT(DISTINCT a1.player_id), 2) AS fraction
FROM Activity a1 JOIN Activity a2
WHERE DATEDIFF(a2.event_date, a1.event_date) < 1
AND a1.player_id = a2.player_id;

A*570. Managers with at Least 5 Direct Reports -> not too bad
# Write your MySQL query statement below
SELECT Name
FROM Employee e1 JOIN (SELECT ManagerId
                       FROM Employee
                       GROUP BY ManagerId
                       HAVING COUNT(ManagerId) >= 5) e2 ON e1.Id = e2.ManagerId;

574. Winning Candidate => If you want to COUNT, you need to GROUP BY usually
# Write your MySQL query statement below
SELECT Name
FROM Candidate JOIN (SELECT Candidateid
                     FROM Vote
                     GROUP BY CandidateId
                     ORDER BY COUNT(CandidateId) DESC
                     LIMIT 1) AS winner
WHERE Candidate.id = winner.Candidateid;

578. Get Highest Answer Rate Question -> makes sense, did not flash
# Write your MySQL query statement below
# find the highest answer rate
SELECT question_id AS survey_log
FROM survey_log
GROUP BY question_id
ORDER BY COUNT(answer_id) / COUNT(IF(action = 'show', 1, 0)) DESC
LIMIT 1;

580. Count Student Number in Departments -> flashed 
# Write your MySQL query statement below
# print dept name and number of students majoring in each dep for all dep in dept table (even ones with no current students)
# sort by number of students DESC, sort by dep't alphabetically
SELECT dept_name, IFNULL(COUNT(student_id), 0) AS student_number
FROM department LEFT JOIN student USING (dept_id)
GROUP BY dept_id
ORDER BY student_number DESC, dept_name ASC;

S*608. Tree Node (no Amazon tag) -> do not fully understand WHERE p_id IS NOT NULL AND p_id IS NOT NULL
# Write your MySQL query statement below
# Write your MySQL query statement below
# root - no parent node
# inner - parent node of some node, NOT NULL parent 
# leaf - rest of the cases
SELECT DISTINCT t1.id,(CASE
                            WHEN t1.p_id IS NULL THEN 'Root'
                            WHEN t1.p_id IS NOT NULL AND t2.id IS NOT NULL THEN 'Inner'
                            WHEN t1.p_id IS NOT NULL AND t2.id IS NULL THEN 'Leaf'
                        END) AS type
FROM tree t1 LEFT JOIN tree t2 ON t1.id = t2.p_id
ORDER BY id ASC;

A*626. Exchange Seats -> the CASE ordering has to be below probably because it depends if last id is odd...
=> CASE solution
# Write your MySQL query statement below
SELECT (CASE
            WHEN id % 2 != 0 AND id != last_id THEN id + 1
            WHEN id % 2 != 0 AND id = last_id THEN id
            ELSE id - 1
        END) AS id, student
FROM seat, (SELECT MAX(id) AS last_id
            FROM seat) AS subquery
ORDER BY id ASC;
#if id is odd, + 1 to even
#if id is even, -1 to odd
#if id = last id, leave

A*1045. Customers Who Bought All Products -> not too difficult, using the COUNT(DISTINCT product_key) to compare both tables
# Write your MySQL query statement below
SELECT customer_id
FROM Customer 
GROUP BY customer_id
HAVING COUNT(DISTINCT product_key) = (SELECT COUNT(DISTINCT product_key) 
                                      FROM product);

A*1070. Product Sales Analysis III (Amazon tag) -> quite easy -> answer makes sense
# Write your MySQL query statement below
SELECT product_id, year AS first_year, quantity, price
FROM Sales
WHERE (product_id, year) IN (SELECT product_id, MIN(year)
                             FROM Sales
                             GROUP BY product_id);

S*1132. Reported Posts II (no Amazon tag) -> have to read question carefully to understand question
# Write your MySQL query statement below
# find the average for daily percentage of posts that got removed after being reported as spam, rounded to 2 decimal places
SELECT ROUND(SUM(percent)/COUNT(DISTINCT action_date), 2) AS average_daily_percent
FROM (SELECT action_date, COUNT(DISTINCT Removals.post_id)/COUNT(DISTINCT Actions.post_id) * 100 AS percent
      FROM Actions LEFT JOIN Removals USING (post_id)
      WHERE extra = 'spam'
      GROUP BY action_date) temp;

S*1212. Team Scores in Football Tournament (no Amazon tag) -> Answer makes sense -> not too hard
# Write your MySQL query statement below
SELECT team_id, team_name,
SUM(CASE WHEN team_id = host_team AND host_goals > guest_goals THEN 3 ELSE 0 END) +
SUM(CASE WHEN team_id = guest_team AND guest_goals > host_goals THEN 3 ELSE 0 END) +
SUM(CASE WHEN team_id = host_team AND host_goals = guest_goals THEN 1 ELSE 0 END) +
SUM(CASE WHEN team_id = guest_team AND guest_goals = host_goals THEN 1 ELSE 0 END) AS num_points
FROM Teams LEFT JOIN Matches ON team_id = host_team OR team_id = guest_team
GROUP BY team_id
ORDER BY num_points DESC, team_id ASC;

S*1270. All People Report to the Given Manager (no Amazon tag) -> Answer kind of makes sense I guess
=> JOIN all 3 table, get e1.employee_id. WHERE e3.manager_id = 1 and e1.employee_id != 1
# Write your MySQL query statement below
# Write an SQL query to find employee_id of all employees that directly or indirectly report their work to the head of the company.
SELECT e1.employee_id
FROM Employees e1 JOIN Employees e2 ON e1.manager_id = e2.employee_id JOIN Employees e3 ON e2.manager_id = e3.employee_id
WHERE e3.manager_id = 1 AND e1.employee_id != 1

S*1341. Moving Rating (no Amazon tag) -> does not seem too bad, answer makes sense
# Write your MySQL query statement below
# find name of user who has greated most number of movies (if tie, return lexicographically smaller user name)
# find movie name with highest average rating in Feb 2020 (if tie, return lexicographically smaller movie name)
(SELECT name AS results 
 FROM Users JOIN Movie_Rating USING(user_id)
 GROUP BY user_id
 ORDER BY COUNT(DISTINCT movie_id) DESC, name ASC 
 LIMIT 1)

UNION

(SELECT title
 FROM Movies JOIN Movie_Rating USING(movie_id)
 WHERE created_at BETWEEN '2020-02-01' AND '2020-02-29'
 GROUP BY movie_id
 ORDER BY AVG(rating) DESC, title ASC
 LIMIT 1)

A*1421. NPV Queries (Amazon tag) -> seems easy
# Write your MySQL query statement below
SELECT id, year, IFNULL(npv, 0) AS npv
FROM Queries LEFT JOIN NPV USING (id, year)
ORDER BY id ASC;
 
 
